import json
import re
import hashlib
from datetime import datetime, timezone, timedelta

# --- CONSTANT DEFINITIONS ---
# This new regex uses named groups for clarity and explicit parsing
_TS    = re.compile(r'^\s*\d{4}-\d{2}-\d{2}[ T]\d{2}:\d{2}:\d{2}(?:[.,]\d+)?Z?\s*')
_TS_TEXT = re.compile(
    r'^\s*(?P<dt>\d{4}-\d{2}-\d{2}[ T]\d{2}:\d{2}:\d{2})' # Main datetime part
    r'(?P<ms>[.,]\d{1,6})?'                             # Optional milliseconds part
)
_BRK = re.compile(r'\[(CRITICAL|FATAL|ERROR|WARNING|INFO|SERVICE|DEBUG|TRACE)\]', re.I)
_BARE = re.compile(r'\b(CRITICAL|FATAL|ERROR|WARNING|INFO|SERVICE|DEBUG|TRACE)\b', re.I)
_NORM = [
    (re.compile(r'\b0x[0-9a-fA-F]+\b'), '<hex>'),
    (re.compile(r'\b[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}\b', re.I), '<uuid>'),
    (re.compile(r'\b\d+\.\d+\.\d+\.\d+\b'), '<ip>'),
    (re.compile(r'\b\d+\b'), '<num>'),
]
_LEVEL_RANK = {'CRITICAL': 5, 'FATAL': 5, 'ERROR': 4, 'WARNING': 3, 'INFO': 2, 'SERVICE': 2, 'DEBUG': 1, 'TRACE': 0}


def _normalise(text: str) -> str:
    for regex, token in _NORM:
        text = regex.sub(token, text)
    return text.strip()

def _first_line(msg: str) -> str:
    if not msg:
        return ""
    return msg.splitlines()[0].strip()

def _hash(text: str) -> str:
    return hashlib.sha1(text.encode()).hexdigest()[:8]


class ExtractSignature:
    def __init__(self, min_severity="WARNING"):
        self.min_level_rank = _LEVEL_RANK.get(min_severity.upper(), 3)

    def _extract_signature(self, log_message: str) -> str:
        # 1. Check for JSON logs
        if log_message.lstrip().startswith('{'):
            try:
                js = json.loads(log_message)
                lvl = str(js.get('level', js.get('severity', 'INFO'))).upper()
                
                if _LEVEL_RANK.get(lvl, 0) < _LEVEL_RANK.get(getattr(self, "min_severity", "WARNING"), 2):
                    return ""
                
                msg = js.get('msg') or js.get('message', '')
                return f"{lvl}: {_normalise(msg)}" if msg else f"{lvl}:"

            except Exception:
                pass 

        # 2. Process text logs
        line = _first_line(log_message)
        line = _TS.sub('', line).strip()

        m = _BRK.search(line) or _BARE.search(line)
        if m:
            level = m.group(1).upper()
            if _LEVEL_RANK.get(level, 0) < _LEVEL_RANK.get(getattr(self, "min_severity", "WARNING"), 2):
                return ""
            
            msg_start = m.end()
            candidate = line[msg_start:].lstrip(":- ").strip()

            # --- MODIFIED LOGIC ---
            # Generalize the check for a trailing JSON object
            # This looks for "Details: {..." or just a JSON blob at the end.
            json_match = re.search(r'(?:Details:)?\s*(\{.*\})$', candidate)
            if json_match:
                json_part = json_match.group(1)
                # Check if it's a valid JSON to avoid false positives
                try:
                    json.loads(json_part)
                    # Get the text part before the JSON
                    main_message_part = candidate[:json_match.start()].strip()
                    # Return ONLY the main message part, discarding the JSON
                    return f"{level}: {_normalise(main_message_part)}"
                except json.JSONDecodeError:
                    # Not a valid JSON, so we fall through and normalize the whole thing
                    pass
            # --- END OF MODIFICATION ---
            
            exc_match = re.search(r'\b(\w+(Exception|Error))\b[^:]*:? (.+)', candidate)
            if exc_match:
                   return _normalise(f"{level}: {exc_match.group(1)} {exc_match.group(3)}")

            return _normalise(f"{level}: {candidate}") if candidate else f"{level}"
        
        # 3. Handle unclassified logs
        return f"UNCLASSIFIED:{_hash(_normalise(line))}"

    def _extract_timestamp(self, log_message: str, parsed_json: dict = None) -> datetime:
        """Extracts a timestamp from a log to iso format, falling back to the current time."""
        # --- NEW: More robust timestamp parsing logic ---
        try:
            # 1. Try to get from parsed JSON first
            if parsed_json:
                ts_val = parsed_json.get('time', parsed_json.get('timestamp', parsed_json.get('ts', parsed_json.get('@timestamp'))))
                if ts_val:
                    # The 'Z' at the end of ISO 8601 timestamps can cause issues, so we handle it.
                    if isinstance(ts_val, str) and ts_val.endswith('Z'):
                        ts_val = ts_val[:-1] + '+00:00'
                    return datetime.fromisoformat(ts_val).replace(tzinfo=timezone.utc)

            # 2. Try to get from text line using explicit regex and strptime
            ts_match = _TS_TEXT.search(log_message)
            if ts_match:
                parts = ts_match.groupdict()
                # Determine the correct format string based on the separator 'T' or ' '
                dt_str = parts['dt']
                fmt = '%Y-%m-%dT%H:%M:%S' if 'T' in dt_str else '%Y-%m-%d %H:%M:%S'
                
                dt_obj = datetime.strptime(dt_str, fmt)
                
                # Add milliseconds if they exist
                if parts['ms']:
                    # Normalize separator and strip it, then convert to microseconds
                    ms_val = parts['ms'].strip('.,')
                    microseconds = int(ms_val.ljust(6, '0'))
                    dt_obj += timedelta(microseconds=microseconds)
                
                return dt_obj.replace(tzinfo=timezone.utc).isoformat()
        except (ValueError, TypeError):
            # If any parsing fails, fall through to returning now()
            pass

        return datetime.now(timezone.utc).isoformat()

    def extract(self, log_message: str) -> dict | None:
        # --- The rest of this method can remain the same ---
        # It now calls the new, more robust _extract_timestamp function.
        if log_message.lstrip().startswith('{'):
            try:
                js = json.loads(log_message)
                level_str = str(js.get('level', js.get('severity', 'INFO'))).upper()
                level_rank = _LEVEL_RANK.get(level_str, 2)
                if level_rank < self.min_level_rank: return None
                ts = self._extract_timestamp(log_message, parsed_json=js)
                msg = js.get('msg') or js.get('message', '')
                signature = f"{level_str}: {_normalise(msg)}" if msg else f"{level_str}:"
                return {'timestamp': ts, 'level_rank': level_rank, 'signature': signature}
            except Exception:
                pass

        line = _first_line(log_message)
        ts = self._extract_timestamp(line)
        line_no_ts = _TS_TEXT.sub('', line).strip()
        
        m = _BRK.search(line_no_ts) or _BARE.search(line_no_ts)
        if m:
            level_str = m.group(1).upper()
            level_rank = _LEVEL_RANK.get(level_str, 2)
            if level_rank < self.min_level_rank: return None
            msg_start = m.end()
            candidate = line_no_ts[msg_start:].lstrip(":- ").strip()
            json_match = re.search(r'(?:Details:)?\s*(\{.*\})$', candidate)
            if json_match:
                try:
                    json.loads(json_match.group(1))
                    candidate = candidate[:json_match.start()].strip()
                except json.JSONDecodeError: pass
            exc_match = re.search(r'\b(\w+(Exception|Error))\b[^:]*:? (.+)', candidate)
            if exc_match:
                signature = f"{level_str}: {_normalise(exc_match.group(1) + ' ' + exc_match.group(3))}"
            else:
                signature = f"{level_str}: {_normalise(candidate)}" if candidate else f"{level_str}"
            return {'timestamp': ts, 'level_rank': level_rank, 'signature': signature}

        signature = f"UNCLASSIFIED:{_hash(_normalise(line))}"
        return {'timestamp': ts, 'level_rank': 0, 'signature': signature}
    
def parse_signature(signature):
    split_signature = signature.split(":", 1)
    category = split_signature[0].strip().upper()
    message = f"{split_signature[1].strip()}" if len(split_signature)==2 else ""
    for keyword in _LEVEL_RANK.keys():
        if keyword in category:
            level = keyword
            break
    else:
        level = category
    return level, message

